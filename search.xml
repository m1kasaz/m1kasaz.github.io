<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>业务功能--优惠券秒杀</title>
      <link href="/2025/07/21/2025.7.21/"/>
      <url>/2025/07/21/2025.7.21/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>最近学习了利用redis解决许多业务问题的方法，优惠券秒杀是其中一个综合性较强的业务问题。</p><h1>全局唯一id</h1><blockquote><p>在优惠券业务中，我们需要向客户端返回订单号，这个订单号在sql中作为订单表的主键，处于安全性等考虑我们不希望订单号在sql表中简单的自增。在redis中以字符串为key的键值对，key中的字符串具有不同的哈希值，且其值是自增的，我们可以利用这一特性制造全局唯一id。</p></blockquote><p>id组成如下：</p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250721175456776.png" alt="image-20250721175456776"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>秒杀下单</h1><blockquote><p>在秒杀下单这一场景下我们后端需要处理许多高并发的业务问题，如超卖问题、一人一单问题等。</p></blockquote><p>主要逻辑流程图：</p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250721190304587.png" alt="image-20250721190304587"></p><p>基础代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">// 7.返回订单</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超卖问题">超卖问题</h2><blockquote><p>在发放优惠券的时候，如果出现多个用户同时进入抢票程序，且由于当时数据库仍有余票未更新，这会导致卖出的票与预想的要多，这在生产环境是十分危险的，为解决并发问题，我们可以利用悲观锁与乐观锁两种思路。</p></blockquote><ul><li>悲观锁：悲观锁认为随时都会有其他线程抢占资源，当前线程获取锁后，其他线程将无法对正常运行。</li><li>乐观锁：乐观锁认为不会有其他线程抢占资源，当前线程与其他线程不会互斥，他们将正常访问资源，但是在更新资源前后都会进行一次比较，若前后的结果不一致，则认为有其他线程更改了资源，当前线程会认为该数据不可用。</li></ul><p>基于乐观锁的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">    <span class="comment">//乐观锁解决超卖问题，没错只需要增加这个语句就可以实现在更新数据前对数据进行比较，只不过这里比较的是库存是否仍有剩余，通常我们会在更新前获取一次该数据，然后在更新时再次对该数据进行获取，与之前的数据进行比较。不过这种方法将导致大量请求被拒绝，因为在该线程从获取到更新这段时间，有很大可能其他线程已经对该数据进行了修改，性能较差，所以可以优化为对当前剩余的库存进行判断。</span></span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">// 7.返回订单</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一人一单问题">一人一单问题</h2><blockquote><p>我们希望优惠券的策略是一人一票，不允许购买多次。实现的方式很简单，我们只需要在对数据库更新前根据用户id访问数据库，如果没有查到记录则认为该用户是第一次购买优惠券，反之则拒绝。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;一个账号只能购买一次优惠券&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 7.2用户id</span></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">// 8.返回订单</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实不难想到上述代码存在的并发问题，如果有人利用数据库录入该账户信息这段时间，多次请求优惠券，这些请求也将被视为合法，因为数据库不能查询到该用户的信息。我们同样利用锁机制解决这个问题，大致思想就是在进行写数据时加一把锁，其他线程的请求将被拒绝，这样就可以放心的更新数据库。</p></blockquote><p>基于悲观锁(synchronized)实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里根据用户id加锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 锁整个函数是为了保证事务提交后，锁才被释放</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">//获取对象的代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> createSeckillVoucher(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createSeckillVoucher</span><span class="params">(Long voucherId)</span>&#123;</span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="comment">// 扣减失败</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">// 7.返回订单</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群服务器">集群服务器</h2><blockquote><p>其实刚刚我们所有场景都是在单机模式下进行的，现阶段的企业开发一般会部署多台服务器来处理请求，但是我们的锁只能在本机中可见，其他服务器是看不到的，也就是说，当我们操作数据库时，其他请求可能通过其他服务器去访问数据库，这样一来又会出现并发问题。我们需要借助分布式锁解决这个问题，分布式锁有很多实现方式，我们采用redis实现。其实这里又涉及许多并发问题，详细可以去b站上看是怎么一步步完善分布式锁的。</p></blockquote><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?spm_id_from=333.788.videopod.episodes&amp;vd_source=ca2923fecc0a3ef7f9bddb75802bcbb4&amp;p=56">实战篇-09.分布式锁-基本原理和不同实现方式对比_哔哩哔哩_bilibili</a></p><p><a href="https://www.runoob.com/lua/lua-basic-syntax.html">Lua 基本语法 | 菜鸟教程</a></p><p>基于redis的分布式锁实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，返回错误或重试</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> createSeckillVoucher(voucherId);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().</span><br><span class="line">                setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用lua脚本</span></span><br><span class="line">        stringRedisTemplate.execute(</span><br><span class="line">                UNLOCK_SCRIPT,</span><br><span class="line">                Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">                ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>到这里我们的锁就是一个勉强可以用的分布式锁了，当然他仍然存在许多问题，感兴趣的可以继续学习基于redisson实现分布式锁。</p><p><a href="https://www.bilibili.com/video/BV1cr4y1671t?spm_id_from=333.788.videopod.episodes&amp;vd_source=ca2923fecc0a3ef7f9bddb75802bcbb4&amp;p=65">实战篇-18.分布式锁-Redisson快速入门_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程变量、全局异常处理器</title>
      <link href="/2025/07/12/2025.7.12/"/>
      <url>/2025/07/12/2025.7.12/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>考完计网和人智基础，好像大二浑浑噩噩就这样过去了，坐了两天火车回家，这几天静下心来把之前的项目给消化一下。</p><h1>线程变量</h1><blockquote><p>有些时候一个线程可能在不同的类方法之间来回调用，调用的时候可能需要重复携带多次相同的变量，这时候我们希望将该变量定义为全局，减少码量的同时项目结构会更清晰，但我们的项目一般是在多线程高并发场景下运行的，这时候线程之间对这个变量的定义可能并不相同，如果我们使用全局变量，线程之间共享这个变量，那我们怎么知道使用的是不是自己定义的变量呢，ThreadLocal给我们提供了一种解决方案。</p></blockquote><h2 id="ThreadLocal是什么">ThreadLocal是什么</h2><p>ThreadLocal就是线程变量，为每个线程所拥有，对其他线程保持隔离。</p><p>它是怎么实现的呢？</p><p>简单来说，你的进程维护了一个Map，这个Map将ThreadLocal作为key存入，其中的value是我们自定义的数据，可以是Integer、String等各种类型，这里只是很简单的描述，详细源码可以看<a href="https://javaguide.cn/java/concurrent/threadlocal.html">JavaGuide中关于ThreadLocal的介绍</a>。</p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocaDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + localVar.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        localVar.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ThreadLocaDemo.localVar.set(<span class="string">&quot;local_A&quot;</span>);</span><br><span class="line">                print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                <span class="comment">//打印本地变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ThreadLocaDemo.localVar.set(<span class="string">&quot;local_B&quot;</span>);</span><br><span class="line">                print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">A :local_A</span><br><span class="line">after remove : <span class="literal">null</span></span><br><span class="line">B :local_B</span><br><span class="line">after remove : <span class="literal">null</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="在项目中的使用">在项目中的使用</h2><blockquote><p>介绍一种token技术和ThreadLocal结合使用的场景</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通常将ThreadLocal封装起来，使其在项目中具有实际意义，这里是将ThreadLocal作为一个存储id的线程变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以在jwt校验的时候将用户的token解析后将id存进去</span></span><br><span class="line"><span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、校验令牌</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">    <span class="comment">//将id存储起来</span></span><br><span class="line">    BaseContext.setCurrentId(empId);</span><br><span class="line">    log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">    <span class="comment">//3、通过，放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">    response.setStatus(<span class="number">401</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employeeDTO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    BeanUtils.copyProperties(employeeDTO, employee);</span><br><span class="line"></span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    employee.setCreateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    employee.setStatus(StatusConstant.ENABLE);</span><br><span class="line"></span><br><span class="line">    employee.setPassword(DigestUtils.md5DigestAsHex(DEFAULT_PASSWORD.getBytes()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用了ThreadLocal中存储的id</span></span><br><span class="line">    employee.setCreateUser(BaseContext.getCurrentId());</span><br><span class="line">    employee.setUpdateUser(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">    employeeMapper.insert(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>全局异常处理器</h1><blockquote><p>有时候写项目，我们会使用try-catch不断将异常捕获，这也是对异常的一种处理方式，但是用户在使用的时候出现问题，他自己是看不到出现的异常的，我们只是捕获异常却没有进行处理，如果在每一次捕获中都对异常进行一次处理，工作量将变得巨大（面向对象变为面向异常，总之Springboot对此提供了一个很好的全局处理器。SpringBoot中，@ControllerAdvice 即可开启全局异常处理，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用@ExceptionHandler注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。</p></blockquote><p>原理咱们先不做讨论（纯不会</p><blockquote><p>这是一个简单的处理sql重复字段的处理器，我们希望给用户返回重复提醒</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器，处理项目中抛出的业务异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获业务异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        <span class="comment">//这里可以将捕获的异常转换为字符串，异常的形式是这样的</span></span><br><span class="line">        <span class="comment">//Duplicate entry &#x27;zhangsi&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span>(message!=<span class="literal">null</span> &amp;&amp; message.contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//这里是对字符串处理，转换为提醒用户的字段</span></span><br><span class="line">            String[] split = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> split[<span class="number">2</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> username + MessageConstant.ALREADY_EXISETS;</span><br><span class="line">            <span class="comment">//返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(MessageConstant.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考</p><ul><li><a href="https://javaguide.cn/java/concurrent/threadlocal.html">JavaGuide</a></li><li><a href="https://blog.csdn.net/qq_41107231/article/details/115874974">CSDN关于全局异常处理器</a></li><li><a href="https://blog.csdn.net/u010445301/article/details/111322569">CSDN关于线程变量</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token令牌技术+Interceptor过滤器</title>
      <link href="/2025/06/29/2025.6.29/"/>
      <url>/2025/06/29/2025.6.29/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><blockquote><p>简单了解一下原理，重点知道怎么用</p></blockquote><p>Token：简单来说就是一个用户在一段时间内的标识，只有登录成功才能获得Token，一般情况下只有携带Token的请求才能被Interceptor放行。</p><p>Interceptor：这是一个过滤器技术，可以将Interceptor理解为一个筛子，在请求到达控制层前进行拦截，根据具体的业务需求，可以对请求进行一定操作，比如拦截、放行等等。</p><hr><h1>Jwt快速入门</h1><h2 id="JwtToken的组成">JwtToken的组成</h2><ul><li>Header</li></ul><p>标头，一般用来标识令牌类型和所使用的签名算法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Payload</li></ul><p>有效载荷，保存自定义信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Signature</li></ul><p>签名，融合了Header和Payload，根据输入的secret基于签名算法生成而来，是保证token不被篡改。</p><p>上面的信息都是json格式的字符串，标头和载荷部分是Base64编码后直接构成token的前两部分，第三部分由标签算法、密钥和输入的信息（Header、Payload）决定。</p><h2 id="Token的创建与验证">Token的创建与验证</h2><blockquote><p>使用jwt提供的工具包快速生成令牌</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成jwt令牌</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jwtCreate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//自定义信息</span></span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;m1kasaz&quot;</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">//将自定义信息加入token</span></span><br><span class="line">            .addClaims(claims)</span><br><span class="line">            <span class="comment">//将签名算法和密钥(基于base64编码)加入token</span></span><br><span class="line">            .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;bTFrYXNheg==&quot;</span>)</span><br><span class="line">            <span class="comment">//设置过期时间为 当前时间+1h</span></span><br><span class="line">            .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">3600</span>*<span class="number">60</span>))</span><br><span class="line">            <span class="comment">//生成</span></span><br><span class="line">            .compact();</span><br><span class="line">    System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析jwt令牌</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jwtParse</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//拿到更改生成的token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJtMWthc2F6IiwiZXhwIjoxNzUxMzgyMDQ0fQ.vuyp1XEZv3ncI-F6U63QlRHymG_du_IlETE0ZiVarfE&quot;</span>;</span><br><span class="line">    <span class="comment">//获取自定义信息</span></span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">            <span class="comment">//设置密钥</span></span><br><span class="line">            .setSigningKey(<span class="string">&quot;bTFrYXNheg==&quot;</span>)</span><br><span class="line">            <span class="comment">//设置需要解析的令牌</span></span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            <span class="comment">//获取自定义信息</span></span><br><span class="line">            .getBody();</span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般将jwt创建和验证封装为工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jwtUtils</span> &#123;</span><br><span class="line">    <span class="comment">//密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> <span class="string">&quot;bTFrYXNheg==&quot;</span>;</span><br><span class="line">    <span class="comment">//持续时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">EXP</span> <span class="operator">=</span> <span class="number">3600</span>*<span class="number">60L</span>;</span><br><span class="line">    <span class="comment">//使用的签名算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SignatureAlgorithm</span> <span class="variable">SIGN</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">    <span class="comment">//创建token</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+EXP))</span><br><span class="line">                .signWith(SIGN, Key)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">parseToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(Key)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Interceptor快速入门</h1><blockquote><p>Interceptor由springboot提供，基于AOP（面向切面编程）思想的过滤技术。</p></blockquote><h2 id="自定义Interceptor">自定义Interceptor</h2><p>想要自定义 <strong>Interceptor</strong>，必须实现HandlerInterceptor或HandlerInterceptorAdapter类中的一个。并需要重写三个方法中至少一个：</p><div class="note info simple"><p>这三个方法都是默认方法，既可以实现也可以不实现。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在请求到达Controller方法之前进行操作，返回true表示放行，返回false表示拒绝</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Controller层方法执行完后该方法会被调用，可以用这个方法实现一些与前端交互的过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一般只用于作资源回收，在前端渲染了相应资源后执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是一个用于控制登录请求的过滤器示例</p><p>主要实现的功能是解析jwt令牌，如果令牌合法就放行，否则拒绝</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenUserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;<span class="comment">//jwt的配置类，用于记录密钥等个人信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getUserTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());</span><br><span class="line">            BaseContext.setCurrentId(userId);</span><br><span class="line">            log.info(<span class="string">&quot;当前用户id：&quot;</span>, userId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册过滤器">注册过滤器</h2><blockquote><p>ok,在知道怎样创建inteceptor过滤器后，我们怎么使用呢？</p><p>其实AOP将自动帮我们完成调用过程，我们只需要知道怎么注册一个inteceptor过滤器就好了。</p><p>注册过程可以借助Springboot的WebMvcConfigurer配置类，如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们刚刚创建的类自动注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenAdminInterceptor jwtTokenAdminInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始注册自定义拦截器...&quot;</span>);</span><br><span class="line">        registry.addInterceptor(jwtTokenAdminInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/admin/**&quot;</span>) <span class="comment">//这个指定了过滤器的作用范围</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/admin/employee/login&quot;</span>); <span class="comment">//这个指定过滤器将排除的请求路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jwt.io/">jwt官方文档</a></p><p><a href="https://blog.csdn.net/Herishwater/article/details/103544342">csdn</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList底层实现</title>
      <link href="/2025/06/27/2025.6.27/"/>
      <url>/2025/06/27/2025.6.27/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>第一次记录源码文章没什么经验，希望从以下几个角度能帮助你加深对java数据结构ArrayList(jdk17)的理解。</p><ul><li><a href="#oringinAnalysis">源码分析</a></li><li><a href="#flowChat">执行流程图</a></li><li><a href="#face">面试题</a></li></ul><h2 id="源码分析-a-id-oringinAnalysis-a">源码分析<a id = "oringinAnalysis"></a></h2><p>下面通过注解方式为大伙简单讲一下底层逻辑</p><h3 id="构造方式">构造方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造时的默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个空数组，用于判断当前数组的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素储存的数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line"><span class="comment">//当前容量，也可以理解为最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入参数为int类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若传入的值大于0，则以传入的值作为数组大小</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造时，初始化一个空数组使用，注意！这里并没有赋予该数组一定的大小。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入参数为集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//先将传入集合转换为数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//判断传入是否是空集合</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//非空且传入集合也是ArrayList，则直接将传入集合的地址赋给我们创建的集合</span></span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*非空但传入集合不是ArrayList，则进行数组的浅拷贝，注意！这里的只会将集合里的属性改变而不改变其地址</span></span><br><span class="line"><span class="comment">            也就是说我们若对传入的集合进行操作是不会影响我们创建的List的</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入元素">插入元素</h3><div class="note info simple"><p>想了一下这里和扩容一起讲比较好</p></div><p>几个插入元素的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//一个其他方法的调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">       <span class="comment">//判断原来的数组大小是否够用</span></span><br><span class="line">       <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">           <span class="comment">//不够用，扩容</span></span><br><span class="line">           elementData = grow();</span><br><span class="line">       <span class="comment">//够用直接插入</span></span><br><span class="line">       elementData[s] = e;</span><br><span class="line">       size = s + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//集合中插入元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//调用了上面的add()方法</span></span><br><span class="line">       add(e, elementData, size);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置插入元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       <span class="comment">//判断插入的位置是否合法</span></span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">       Object[] elementData;</span><br><span class="line">       <span class="comment">//判断数组是否够长</span></span><br><span class="line">       <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length)</span><br><span class="line">           <span class="comment">//不够长扩容</span></span><br><span class="line">           elementData = grow();</span><br><span class="line">       <span class="comment">//改变其他元素的位置，就是将该下标后的所有元素拷贝到该下标+1位置后</span></span><br><span class="line">       System.arraycopy(elementData, index,</span><br><span class="line">                        elementData, index + <span class="number">1</span>,</span><br><span class="line">                        s - index);</span><br><span class="line">       <span class="comment">//插入元素</span></span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size = s + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>下面是扩容操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">       <span class="comment">//记录老容量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">       <span class="comment">//如果并不是第一次扩容</span></span><br><span class="line">       <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                   minCapacity - oldCapacity, <span class="comment">/*最小扩容量 minimum growth */</span></span><br><span class="line">                   oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/*首选增长量 preferred growth */</span>);</span><br><span class="line">           <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//第一次扩容至默认容量10</span></span><br><span class="line">           <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">       <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">       <span class="comment">//如果不是第一次扩容，就将两倍的老容量直接返回</span></span><br><span class="line">       <span class="comment">//SOFT_MAX_ARRAY_LENGTH = INTEGER_MAX-8</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">           <span class="keyword">return</span> prefLength;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这个方法不用细看，只要知道最大长度是INTEGER_MAX就行</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;</span><br><span class="line">       <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(</span><br><span class="line">               <span class="string">&quot;Required array length &quot;</span> + oldLength + <span class="string">&quot; + &quot;</span> + minGrowth + <span class="string">&quot; is too large&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">           <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> minLength;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="数组转List">数组转List</h3><div class="note info simple"><p>改变数组会影响List</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是将array的地址直接传给了a</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">   &#125;</span><br><span class="line">   ArrayList(E[] array) &#123;</span><br><span class="line">       <span class="comment">//这个方法用来获取数组的地址</span></span><br><span class="line">       a = Objects.requireNonNull(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="List转数组">List转数组</h3><div class="note info simple"><p>改变List不会影响数组</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//这里很明显是进行了一次拷贝而不是地址传递</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="流程图-a-id-flowChat-a">流程图<a id = "flowChat"></a></h2><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250628230220153.png" alt="image-20250628230220153"></p><hr><h2 id="面试题-a-id-face-a">面试题<a id = "face"></a></h2><ul><li><strong>ArrayList底层的实现原理是什么</strong></li></ul><p>ArrayList底层是用动态的数组实现的。<br>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10。<br>ArrayList在进行扩容的时候是原来容量的2倍，每次扩容都需要拷贝数组。<br>ArrayList在添加数据的时候。<br>确保数组已使用长度（size）加1之后足够存下下一个数据。<br>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的2倍)。<br>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。<br>返回添加成功布尔值。</p><ul><li><p><strong>如何实现List和数组之间的转换(可参考实现原理)</strong></p></li><li><p><strong>ArrayList和LinkedList的区别是什么</strong></p></li></ul><p>底层数据结构：</p><p>ArrayList是基于动态数组（时间、空间）</p><p>LinkedList是基于双向链表（时间、空间）</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql语句的执行逻辑</title>
      <link href="/2025/06/25/2025.6.25/"/>
      <url>/2025/06/25/2025.6.25/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql的架构">Mysql的架构</h2><p>简单来说Mysql分为Server层和存储引擎层。</p><h3 id="Server层">Server层</h3><p><strong>主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</strong></p><ul><li>连接器：身份认证和权限分析。</li><li>缓存（Mysql8.0中移除）：将近期查询结果储存下来，加快查询效率。</li><li>分析器：词法分析和语法分析。</li><li>优化器：优化查询路径。</li><li>执行器：执行语句和返回结果。</li></ul><p>（架构关系如图所示）</p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/mmexport1750848916079.png" alt="mmexport1750848916079"></p><h3 id="存储引擎层">存储引擎层</h3><p><strong>主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></p><hr><h2 id="语句分析">语句分析</h2><p>Mysql的语句分为查询与更新（增删改）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 1 and name = &quot;张三&quot;</span><br></pre></td></tr></table></figure><p>对于这一条查询语句，Mysql的执行流程可以这样解释：在语句分析前，连接器就会对用户进行权限分析，判断是否有执行该语句的权力，然后程序将访问缓存（Mysql8.0版本前），查询语句的对应结果，如果缓存中没有对应的Key-Value，分析器将对程序进行词法分析，提取如<strong>where，select</strong>等关键词与<strong>表名，字段名</strong>等信息，语法分析将对该语句的语法进行判断，若语法正确，程序将按照优化器给出的最佳路径**（这里的最佳路径只是优化器认为的最佳，而不是我们认为的，对于上面这一条一句，程序既有可能先对id字段查询，也有可能先对name字段查询）**执行查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set id = 1 where id = 2</span><br></pre></td></tr></table></figure><p>对于这一条更新语句，流程大体与查询语句相似，由于涉及对数据库表的更新，更新语句不会访问缓存。更新语句将涉及日志模块，Mysql自带的日志模块是<strong>binlog（归档日志）</strong>，所有的存储引擎都可使用，我们常用的<strong>InnoDB</strong>还自带一个**redolog（重做日志）**模块，下面将以InnoDB引擎讨论程序执行流程。</p><p>查询到id为2这一条字段后，将id设置为1，然后调用<strong>InnoDB</strong>的API接口写入这一条数据，然后告诉执行器完成执行，引擎将调用<strong>redolog</strong>将其设置为<strong>prepare就绪状态</strong>，执行器记录binlog日志后告知引擎设置<strong>redolog为提交状态</strong>，更新完成。</p><hr><ul><li><a href="https://dev.mysql.com/doc/refman/8.4/en/">Mysql官方参考手册</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程中wait/notify机制</title>
      <link href="/2025/06/24/2025.6.24/"/>
      <url>/2025/06/24/2025.6.24/</url>
      
        <content type="html"><![CDATA[<h3 id="wait-notify机制">wait/notify机制</h3><ul><li>wait():在获得对象锁后主动进入等待状态让出对象锁。</li><li>notify():同样时通知正在等待的其他线程，主动让出对象锁，但是，与 wait() 方法不同，执行 notify() 后，不会立即释放对象锁，而需要执行完 synchronize 的代码块或方法才会释放锁，所以接收通知的线程也不会立即获得锁，也需要等待执行 notify() 方法的线程释放锁后再获取锁。</li></ul><h3 id="应用">应用</h3><div class="note info simple"><p>问题：写两个线程打印1-100，一个线程打印奇数，一个线程打印偶数</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="comment">//打印的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义对象锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span>&#123;</span><br><span class="line">        print(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span>&#123;</span><br><span class="line">        print(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Printer</span><span class="params">(<span class="type">int</span> max)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> isOdd)</span>&#123;</span><br><span class="line">        <span class="comment">//每个线程各执行50次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="comment">//判断当前是轮到哪个线程执行</span></span><br><span class="line">                <span class="keyword">while</span> (isOdd == (count%<span class="number">2</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="comment">//若不是当前线程执行时机则让出锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;: &quot;</span>+count++);</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="string">&quot;Odd&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">even</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="string">&quot;Even&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        odd.start();</span><br><span class="line">        even.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watch监听函数</title>
      <link href="/2025/06/24/2025.6.23/"/>
      <url>/2025/06/24/2025.6.23/</url>
      
        <content type="html"><![CDATA[<h3 id="属性监听">属性监听</h3><ul><li><p>源对象是一个ref的属性值及其衍生式</p></li><li><p>当监听的属性值发生变化时会触发监听函数执行响应的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个 ref</span></span><br><span class="line"><span class="title function_">watch</span>(x, <span class="function">(<span class="params">newX</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> x.<span class="property">value</span> + y.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个来源组成的数组</span></span><br><span class="line"><span class="title function_">watch</span>([x, <span class="function">() =&gt;</span> y.<span class="property">value</span>], <span class="function">(<span class="params">[newX, newY]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> and y is <span class="subst">$&#123;newY&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="对象监听">对象监听</h3><h4 id="1-对象的全部属性">1.对象的全部属性</h4><ul><li>源对象是一个ref的对象值</li><li>浅层监听：对ref对象内的属性进行更改时不会触发监听</li><li>深层监听：当ref对象内任一属性发生更改时都会触发，但是性能开销更大</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line"><span class="title function_">watch</span>(user, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">&#125;,(<span class="attr">deep</span>:<span class="literal">true</span>)<span class="comment">//开启深度监听</span></span><br></pre></td></tr></table></figure><h4 id="2-对象的单个属性">2.对象的单个属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> searchEmp = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">date</span>: [],</span><br><span class="line">  <span class="attr">begin</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//侦听searchEmp中的date属性</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="comment">//这里需要用一个对象属性的getter方法，禁止属性值直接传入</span></span><br><span class="line">  <span class="function">() =&gt;</span> searchEmp.<span class="property">value</span>.<span class="property">date</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(newValue.<span class="property">length</span> == <span class="number">2</span>)&#123;</span><br><span class="line">      searchEmp.<span class="property">value</span>.<span class="property">begin</span> = newValue[<span class="number">0</span>]</span><br><span class="line">      searchEmp.<span class="property">value</span>.<span class="property">end</span> = newValue[<span class="number">1</span>]</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      searchEmp.<span class="property">value</span>.<span class="property">begin</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      searchEmp.<span class="property">value</span>.<span class="property">end</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><a href="https://cn.vuejs.org/guide/essentials/watchers">官方文档</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueRouter</title>
      <link href="/2025/06/22/2025.6.22/"/>
      <url>/2025/06/22/2025.6.22/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>VueRouter（以下称为route）是Vue提供的路由组件，主要由3方面构成：</p><ul><li><p>router-link：请求链接组件，浏览器会解析成a标签</p></li><li><p>router-view：动态视图组件，用来渲染展示与路由路径对应的组件</p></li><li><p>路由表router如下图</p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250622181125012.png" alt="image-20250622181125012"></p></li></ul><p>下面我们从三个角度了解route</p><hr><h3 id="router-link">router-link</h3><p>该标签通常添加在button，menu等标签外，表示点击该组件，启动路由跳到下一个页面，例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span> //添加下一跳的地址</span><br><span class="line">    <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/index&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-icon</span>&gt;</span><span class="tag">&lt;<span class="name">Promotion</span> /&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span> 首页</span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>element的menu组件中集成了该功能上述代码等价于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">router</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;/index&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-icon</span>&gt;</span><span class="tag">&lt;<span class="name">Promotion</span> /&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span> 首页</span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在顶级菜单栏中添加&quot;router&quot;即可，会自动根据index中的内容寻找下一跳的地址</p><hr><h3 id="router-view">router-view</h3><p><strong>动态渲染组件</strong>，将下一跳的组件在标签位置渲染出来，通常加在具有container功能的标签内。例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line">//下一跳的组件将加载在<span class="tag">&lt;<span class="name">el-main</span>&gt;</span><span class="tag">&lt;/<span class="name">el_main</span>&gt;</span>的内容里</span><br></pre></td></tr></table></figure><hr><h3 id="路由表router">路由表router</h3><p>决定该路径下，访问的组件是什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入IndexView组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">IndexView</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/index/index.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line"><span class="comment">//配置路由信息</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/index&#x27;</span>, <span class="attr">component</span>: <span class="title class_">IndexView</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><hr><p>进阶用法:</p><ul><li><a href="https://router.vuejs.org/zh/guide/essentials/nested-routes.html">嵌套路由</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二级域名及vercel绑定</title>
      <link href="/2025/06/19/2025.6.19/"/>
      <url>/2025/06/19/2025.6.19/</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>这里默认大家已经拥有自己的域名，创建二级域名主要目的是：<br>在你主域名已经绑定的前提下，不想重新再买一个域名进行别的网站的绑定</p><hr><h3 id="创建二级域名">创建二级域名</h3><p>打开你购买域名的官网（这里以<a href="https://www.aliyun.com">阿里云</a>为例）</p><div class="note info simple"><p>搜索域名控制台，进入域名管理</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620173247119.png" alt="image-20250620173247119"></p><div class="note info simple"><p>进入<strong>域名列表</strong>，点击解析</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620173415215.png" alt="image-20250620173415215"></p><div class="note info simple"><p>点击<strong>添加域名</strong>，填入域名的名字<strong>前缀不能是大写</strong></p></div><h6 id="image-20250620173742135"><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620173742135.png" alt="image-20250620173742135"></h6><div class="note info simple"><p>点击<strong>TXT授权校验</strong>，保存TXT记录</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620173948316.png" alt="image-20250620173948316"></p><div class="note info simple"><p>进入主域名的<strong>解析设置</strong>，<strong>这里一定得是主域名！</strong></p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620174108097.png" alt="image-20250620174108097"></p><div class="note info simple"><p><strong>添加记录</strong>，将记录填入，<strong>记录类型要选择TXT</strong></p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620174343636.png" alt="image-20250620174343636"></p><div class="note info simple"><p>返回进行TXT检测</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620174610973.png" alt="image-20250620174610973"></p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620174649423.png" alt="image-20250620174649423"></p><h3 id="将域名解析至vercel">将域名解析至vercel</h3><div class="note info simple"><p>这里假设你已经在vercel上面创建好项目，准备绑定域名</p></div><ul><li><p>进入项目，点击<strong>Domains</strong></p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620181547727.png" alt="image-20250620181547727"></p></li><li><p>点击<strong>add domains</strong>，输入你的域名并保存</p><div class="note warning simple"><p>你会看到Invalid Configuration的警告，这是因为你还没有配置</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620181638318.png" alt="image-20250620181638318"></p></li><li><p>点击进入解析页面，将记录值保存下来</p><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620181713838.png" alt="image-20250620181713838"></p></li><li><p>回到阿里云域名列表，对你的二级域名解析设置</p><div class="note warning simple"><p>是刚刚创建的二级域名!</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620181759564.png" alt=""></p></li><li><p>添加两条解析记录</p><div class="note warning simple"><p>第一条基本是一样的，记录值为76.76.21.21</p><p>第二条就要看你的记录填了</p></div><p><img src="https://m1kasaz-typora.oss-cn-beijing.aliyuncs.com/images/image-20250620181823482.png" alt="image-20250620181823482"></p></li><li><p>返回vercel，正常情况下你的域名就绑定成功了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初帖</title>
      <link href="/2025/06/18/2025.6.18/"/>
      <url>/2025/06/18/2025.6.18/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>写下这贴时博主已经被2级域名创建折磨得痛不欲生啊啊啊<br>家人们在阿里云添加二级域名的前缀首字母一定不要大写 😭 😭 (2025.6.18 23:44)</p><h1>建站初衷</h1><p>博主一字蔡，希望在这里分享一些自己学到的技术，遇到的问题吧，给自己一些动力。<br>也欢迎大家在评论区友好交流，一起进步。</p><p>建站是参考了好几个哥的文章: <a href="https://github.com/m1kasaz/m1kasaz.github.io?tab=readme-ov-file">README</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
